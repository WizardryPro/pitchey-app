name: Release Management Pipeline

permissions:
  contents: write
  pull-requests: write
  issues: write
  packages: write

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto      # Automatic based on commit messages
          - patch     # Bug fixes
          - minor     # New features
          - major     # Breaking changes
          - prerelease # Pre-release version
      skip_build:
        description: 'Skip build and deploy'
        required: false
        default: false
        type: boolean
      draft_release:
        description: 'Create as draft release'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'

jobs:
  # Analyze commits for semantic versioning
  analyze-changes:
    runs-on: blacksmith-4vcpu-ubuntu-2404
    outputs:
      should-release: ${{ steps.semantic-analysis.outputs.should-release }}
      release-type: ${{ steps.semantic-analysis.outputs.release-type }}
      new-version: ${{ steps.semantic-analysis.outputs.new-version }}
      changelog: ${{ steps.generate-changelog.outputs.changelog }}
      breaking-changes: ${{ steps.semantic-analysis.outputs.breaking-changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog
      
      - name: Install semantic versioning tools
        run: |
          npm install -g conventional-changelog-cli conventional-recommended-bump
          sudo apt-get update && sudo apt-get install -y jq git
      
      - name: Get current version
        id: current-version
        run: |
          # Get current version from package.json or create initial version
          if [ -f "frontend/package.json" ]; then
            CURRENT_VERSION=$(jq -r '.version // "0.0.0"' frontend/package.json)
          else
            CURRENT_VERSION="0.0.0"
          fi
          
          # Get latest git tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          LATEST_TAG_VERSION=$(echo "$LATEST_TAG" | sed 's/^v//')
          
          # Use the higher version
          if [ "$(printf '%s\n' "$CURRENT_VERSION" "$LATEST_TAG_VERSION" | sort -V | tail -n1)" = "$LATEST_TAG_VERSION" ]; then
            VERSION="$LATEST_TAG_VERSION"
          else
            VERSION="$CURRENT_VERSION"
          fi
          
          echo "current-version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"
      
      - name: Semantic analysis of commits
        id: semantic-analysis
        run: |
          CURRENT_VERSION="${{ steps.current-version.outputs.current-version }}"
          RELEASE_TYPE="${{ inputs.release_type }}"
          
          # Get commits since last release
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            COMMIT_RANGE="$LAST_TAG..HEAD"
          else
            COMMIT_RANGE="HEAD"
          fi
          
          COMMITS=$(git log --pretty=format:"%h %s" $COMMIT_RANGE)
          echo "Analyzing commits since $LAST_TAG:"
          echo "$COMMITS"
          
          # Analyze commit messages for semantic versioning
          BREAKING_CHANGES=$(echo "$COMMITS" | grep -E "(BREAKING CHANGE|!:|feat!:|fix!:)" | wc -l)
          FEATURES=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ feat(\(.+\))?:" | wc -l)
          FIXES=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ fix(\(.+\))?:" | wc -l)
          DOCS=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ docs(\(.+\))?:" | wc -l)
          REFACTOR=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ refactor(\(.+\))?:" | wc -l)
          PERF=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ perf(\(.+\))?:" | wc -l)
          CHORE=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ chore(\(.+\))?:" | wc -l)
          
          # Determine release type
          if [ "$RELEASE_TYPE" != "auto" ]; then
            DETERMINED_TYPE="$RELEASE_TYPE"
          elif [ $BREAKING_CHANGES -gt 0 ]; then
            DETERMINED_TYPE="major"
          elif [ $FEATURES -gt 0 ] || [ $PERF -gt 0 ]; then
            DETERMINED_TYPE="minor"
          elif [ $FIXES -gt 0 ] || [ $REFACTOR -gt 0 ]; then
            DETERMINED_TYPE="patch"
          elif [ $DOCS -gt 0 ] || [ $CHORE -gt 0 ]; then
            DETERMINED_TYPE="patch"
          else
            DETERMINED_TYPE="none"
          fi
          
          # Should we create a release?
          if [ "$DETERMINED_TYPE" != "none" ] || [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            SHOULD_RELEASE="true"
          else
            SHOULD_RELEASE="false"
          fi
          
          # Calculate new version
          if [ "$SHOULD_RELEASE" == "true" ]; then
            case "$DETERMINED_TYPE" in
              major)
                NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{$1++; $2=0; $3=0; print $1"."$2"."$3}')
                ;;
              minor)
                NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{$2++; $3=0; print $1"."$2"."$3}')
                ;;
              patch)
                NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{$3++; print $1"."$2"."$3}')
                ;;
              prerelease)
                NEW_VERSION="$CURRENT_VERSION-pre.$(date +%Y%m%d%H%M%S)"
                ;;
              *)
                NEW_VERSION="$CURRENT_VERSION"
                ;;
            esac
          else
            NEW_VERSION="$CURRENT_VERSION"
          fi
          
          echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "release-type=$DETERMINED_TYPE" >> $GITHUB_OUTPUT
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "breaking-changes=$BREAKING_CHANGES" >> $GITHUB_OUTPUT
          
          echo "Release Analysis:"
          echo "- Should Release: $SHOULD_RELEASE"
          echo "- Release Type: $DETERMINED_TYPE"
          echo "- Current Version: $CURRENT_VERSION"
          echo "- New Version: $NEW_VERSION"
          echo "- Breaking Changes: $BREAKING_CHANGES"
          echo "- Features: $FEATURES"
          echo "- Fixes: $FIXES"
      
      - name: Generate changelog
        id: generate-changelog
        if: steps.semantic-analysis.outputs.should-release == 'true'
        run: |
          echo "ðŸ“ Generating changelog..."
          
          # Get the last tag for changelog generation
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          NEW_VERSION="${{ steps.semantic-analysis.outputs.new-version }}"
          
          # Create changelog using conventional-changelog
          if [ -n "$LAST_TAG" ]; then
            COMMIT_RANGE="$LAST_TAG..HEAD"
          else
            COMMIT_RANGE="HEAD"
          fi
          
          # Generate changelog content
          cat > changelog-template.md << 'EOF'
          # Changelog
          
          ## [{{ version }}] - {{ date }}
          
          ### ðŸš€ Features
          {{ features }}
          
          ### ðŸ› Bug Fixes
          {{ fixes }}
          
          ### ðŸ’¥ Breaking Changes
          {{ breaking }}
          
          ### ðŸ“š Documentation
          {{ docs }}
          
          ### ðŸ”§ Maintenance
          {{ chore }}
          
          ### âš¡ Performance
          {{ perf }}
          
          ### ðŸŽ¨ Refactoring
          {{ refactor }}
          
          EOF
          
          # Extract different types of changes
          FEATURES=$(git log --pretty=format:"- %s (%h)" $COMMIT_RANGE | grep -E "^- feat(\(.+\))?:" | sed 's/^- //' || echo "No new features")
          FIXES=$(git log --pretty=format:"- %s (%h)" $COMMIT_RANGE | grep -E "^- fix(\(.+\))?:" | sed 's/^- //' || echo "No bug fixes")
          BREAKING=$(git log --pretty=format:"- %s (%h)" $COMMIT_RANGE | grep -E "(BREAKING CHANGE|!:|feat!:|fix!:)" | sed 's/^- //' || echo "No breaking changes")
          DOCS=$(git log --pretty=format:"- %s (%h)" $COMMIT_RANGE | grep -E "^- docs(\(.+\))?:" | sed 's/^- //' || echo "No documentation changes")
          CHORE=$(git log --pretty=format:"- %s (%h)" $COMMIT_RANGE | grep -E "^- chore(\(.+\))?:" | sed 's/^- //' || echo "No maintenance changes")
          PERF=$(git log --pretty=format:"- %s (%h)" $COMMIT_RANGE | grep -E "^- perf(\(.+\))?:" | sed 's/^- //' || echo "No performance improvements")
          REFACTOR=$(git log --pretty=format:"- %s (%h)" $COMMIT_RANGE | grep -E "^- refactor(\(.+\))?:" | sed 's/^- //' || echo "No refactoring")
          
          # Build changelog
          CHANGELOG="# Release v$NEW_VERSION - $(date +'%Y-%m-%d')

          ## ðŸš€ Features
          $FEATURES

          ## ðŸ› Bug Fixes
          $FIXES

          ## ðŸ’¥ Breaking Changes
          $BREAKING

          ## ðŸ“š Documentation
          $DOCS

          ## ðŸ”§ Maintenance
          $CHORE

          ## âš¡ Performance Improvements
          $PERF

          ## ðŸŽ¨ Code Refactoring
          $REFACTOR

          ## ðŸ“Š Statistics
          - Total commits: $(git rev-list --count $COMMIT_RANGE)
          - Files changed: $(git diff --name-only $COMMIT_RANGE | wc -l)
          - Contributors: $(git shortlog -sn $COMMIT_RANGE | wc -l)
          "
          
          # Save changelog to file and output
          echo "$CHANGELOG" > release-changelog.md
          
          # Escape for GitHub output
          CHANGELOG_ESCAPED=$(echo "$CHANGELOG" | sed ':a;N;$!ba;s/\n/%0A/g')
          echo "changelog=$CHANGELOG_ESCAPED" >> $GITHUB_OUTPUT
          
          echo "âœ… Changelog generated"

  # Update version in files
  update-version:
    needs: analyze-changes
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: needs.analyze-changes.outputs.should-release == 'true'
    outputs:
      version-updated: ${{ steps.update-files.outputs.version-updated }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Update version in project files
        id: update-files
        run: |
          NEW_VERSION="${{ needs.analyze-changes.outputs.new-version }}"
          
          echo "ðŸ“ Updating version to $NEW_VERSION in project files..."
          
          # Update frontend package.json
          if [ -f "frontend/package.json" ]; then
            jq --arg version "$NEW_VERSION" '.version = $version' frontend/package.json > tmp.json
            mv tmp.json frontend/package.json
            echo "âœ… Updated frontend/package.json"
          fi
          
          # Update root package.json if it exists
          if [ -f "package.json" ]; then
            jq --arg version "$NEW_VERSION" '.version = $version' package.json > tmp.json
            mv tmp.json package.json
            echo "âœ… Updated package.json"
          fi
          
          # Create version file
          cat > VERSION << EOF
          $NEW_VERSION
          EOF
          
          # Update version in worker code
          if [ -f "src/worker-production-db.ts" ]; then
            sed -i "s/version: ['\"].*['\"]/version: '$NEW_VERSION'/g" src/worker-production-db.ts
            echo "âœ… Updated version in worker code"
          fi
          
          # Check if any files were modified
          if git diff --quiet; then
            echo "version-updated=false" >> $GITHUB_OUTPUT
            echo "No files needed updating"
          else
            echo "version-updated=true" >> $GITHUB_OUTPUT
            echo "Files updated successfully"
          fi
      
      - name: Commit version updates
        if: steps.update-files.outputs.version-updated == 'true'
        run: |
          NEW_VERSION="${{ needs.analyze-changes.outputs.new-version }}"
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          git add -A
          git commit -m "chore: bump version to v$NEW_VERSION"
          git push

  # Build and test before release
  pre-release-build:
    needs: [analyze-changes, update-version]
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: needs.analyze-changes.outputs.should-release == 'true' && !inputs.skip_build
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci
      
      - name: Build frontend
        working-directory: frontend
        env:
          NODE_ENV: production
        run: npm run build
      
      - name: Package release artifacts
        run: |
          NEW_VERSION="${{ needs.analyze-changes.outputs.new-version }}"
          
          # Create release package
          mkdir -p release-artifacts
          
          # Frontend build
          if [ -d "frontend/dist" ]; then
            tar -czf "release-artifacts/frontend-v$NEW_VERSION.tar.gz" -C frontend dist/
            echo "âœ… Packaged frontend build"
          fi
          
          # Backend source
          tar -czf "release-artifacts/backend-v$NEW_VERSION.tar.gz" \
            --exclude='node_modules' \
            --exclude='.git' \
            --exclude='frontend/dist' \
            --exclude='release-artifacts' \
            .
          echo "âœ… Packaged backend source"
          
          # Create checksums
          cd release-artifacts
          sha256sum *.tar.gz > checksums.sha256
          echo "âœ… Generated checksums"
      
      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts-${{ needs.analyze-changes.outputs.new-version }}
          path: release-artifacts/
          retention-days: 90

  # Create GitHub release
  create-release:
    needs: [analyze-changes, update-version, pre-release-build]
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: always() && needs.analyze-changes.outputs.should-release == 'true'
    outputs:
      release-id: ${{ steps.create-release.outputs.release-id }}
      release-url: ${{ steps.create-release.outputs.release-url }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Download release artifacts
        if: needs.pre-release-build.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts-${{ needs.analyze-changes.outputs.new-version }}
          path: release-artifacts/
      
      - name: Create Git tag
        run: |
          NEW_VERSION="${{ needs.analyze-changes.outputs.new-version }}"

          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Check if tag already exists
          if git rev-parse "v$NEW_VERSION" >/dev/null 2>&1; then
            echo "âš ï¸ Tag v$NEW_VERSION already exists, skipping tag creation"
            exit 0
          fi

          # Create and push tag
          git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
          git push origin "v$NEW_VERSION"

          echo "âœ… Created tag v$NEW_VERSION"
      
      - name: Create GitHub release
        id: create-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ needs.analyze-changes.outputs.new-version }}"
          RELEASE_TYPE="${{ needs.analyze-changes.outputs.release-type }}"
          BREAKING_CHANGES="${{ needs.analyze-changes.outputs.breaking-changes }}"
          
          # Prepare release notes
          CHANGELOG="${{ needs.analyze-changes.outputs.changelog }}"
          CHANGELOG_DECODED=$(echo "$CHANGELOG" | sed 's/%0A/\n/g')
          
          # Add release metadata
          RELEASE_NOTES="$CHANGELOG_DECODED

          ## ðŸš€ Deployment Information

          ### Production URLs
          - **Frontend**: https://pitchey-5o8.pages.dev
          - **API**: https://pitchey-api-prod.ndlovucavelle.workers.dev
          - **Health Check**: https://pitchey-api-prod.ndlovucavelle.workers.dev/api/health

          ### Release Metadata
          - **Release Type**: $RELEASE_TYPE
          - **Breaking Changes**: $BREAKING_CHANGES
          - **Commit**: ${{ github.sha }}
          - **Build Date**: $(date -u)
          - **Environment**: Production

          ### Deployment Commands
          \`\`\`bash
          # Deploy Worker
          wrangler deploy

          # Deploy Frontend
          wrangler pages deploy frontend/dist --project-name=pitchey
          \`\`\`

          ### Rollback Instructions
          If issues arise, rollback using:
          \`\`\`bash
          # Rollback to previous version
          wrangler rollback
          \`\`\`
          "
          
          # Determine if pre-release
          PRERELEASE="false"
          if [ "$RELEASE_TYPE" == "prerelease" ] || [[ "$NEW_VERSION" == *"-"* ]]; then
            PRERELEASE="true"
          fi
          
          # Determine if draft
          DRAFT="${{ inputs.draft_release }}"
          
          # Check if release already exists using gh cli
          if gh release view "v$NEW_VERSION" --json id --jq '.id' 2>/dev/null; then
            echo "âš ï¸ Release v$NEW_VERSION already exists, skipping creation"
            RELEASE_URL=$(gh release view "v$NEW_VERSION" --json url --jq '.url')
            echo "release-id=existing" >> $GITHUB_OUTPUT
            echo "release-url=$RELEASE_URL" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Write release notes to a file for proper handling
          echo "$RELEASE_NOTES" > release-notes.md

          # Create release using gh cli (handles escaping properly)
          PRERELEASE_FLAG=""
          if [ "$PRERELEASE" == "true" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi

          DRAFT_FLAG=""
          if [ "$DRAFT" == "true" ]; then
            DRAFT_FLAG="--draft"
          fi

          gh release create "v$NEW_VERSION" \
            --title "Release v$NEW_VERSION" \
            --notes-file release-notes.md \
            --target "${{ github.sha }}" \
            $PRERELEASE_FLAG $DRAFT_FLAG

          RELEASE_URL=$(gh release view "v$NEW_VERSION" --json url --jq '.url')
          echo "release-id=new" >> $GITHUB_OUTPUT
          echo "release-url=$RELEASE_URL" >> $GITHUB_OUTPUT

          echo "âœ… Created release v$NEW_VERSION"
          echo "ðŸ”— Release URL: $RELEASE_URL"
      
      - name: Upload release assets
        if: needs.pre-release-build.result == 'success'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RELEASE_ID="${{ steps.create-release.outputs.release-id }}"
          
          if [ -d "release-artifacts" ]; then
            for file in release-artifacts/*; do
              if [ -f "$file" ]; then
                filename=$(basename "$file")
                
                echo "Uploading $filename..."
                
                curl -X POST \
                  -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Content-Type: application/octet-stream" \
                  --data-binary "@$file" \
                  "https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets?name=$filename"
                
                echo "âœ… Uploaded $filename"
              fi
            done
          fi

  # Trigger deployment pipeline
  trigger-deployment:
    needs: [analyze-changes, create-release]
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: needs.create-release.result == 'success' && !inputs.skip_build
    steps:
      - name: Trigger production deployment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ needs.analyze-changes.outputs.new-version }}"
          
          echo "ðŸš€ Triggering production deployment for v$NEW_VERSION..."
          
          # Trigger the main CI/CD pipeline
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/cloudflare-deploy.yml/dispatches" \
            -d '{
              "ref": "main",
              "inputs": {
                "environment": "production",
                "skip_tests": "false"
              }
            }'
          
          echo "âœ… Production deployment triggered"

  # Post-release notifications and updates
  post-release:
    needs: [analyze-changes, create-release, trigger-deployment]
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: always() && needs.create-release.result == 'success'
    steps:
      - name: Update dependency tracking
        run: |
          NEW_VERSION="${{ needs.analyze-changes.outputs.new-version }}"
          
          echo "ðŸ“¦ Checking for dependency updates after release..."
          
          # Create dependency update issue if this is a major release
          if [ "${{ needs.analyze-changes.outputs.release-type }}" == "major" ]; then
            echo "Major release detected, dependency audit recommended"
            
            # This would typically trigger a dependency update workflow
            # or create an issue for manual review
          fi
      
      - name: Generate release metrics
        run: |
          NEW_VERSION="${{ needs.analyze-changes.outputs.new-version }}"
          RELEASE_URL="${{ needs.create-release.outputs.release-url }}"
          
          echo "ðŸ“Š Release Metrics for v$NEW_VERSION"
          echo "=================================="
          echo "Release Type: ${{ needs.analyze-changes.outputs.release-type }}"
          echo "Breaking Changes: ${{ needs.analyze-changes.outputs.breaking-changes }}"
          echo "Release URL: $RELEASE_URL"
          echo "Build Status: ${{ needs.pre-release-build.result }}"
          echo "Deployment Status: ${{ needs.trigger-deployment.result }}"
          echo "Release Time: $(date -u)"
          
          # Create metrics file
          cat > release-metrics.json << EOF
          {
            "version": "$NEW_VERSION",
            "releaseType": "${{ needs.analyze-changes.outputs.release-type }}",
            "breakingChanges": ${{ needs.analyze-changes.outputs.breaking-changes }},
            "releaseUrl": "$RELEASE_URL",
            "buildStatus": "${{ needs.pre-release-build.result }}",
            "deploymentStatus": "${{ needs.trigger-deployment.result }}",
            "releaseTime": "$(date -u --iso-8601=seconds)",
            "commit": "${{ github.sha }}"
          }
          EOF
      
      - name: Upload release metrics
        uses: actions/upload-artifact@v4
        with:
          name: release-metrics-${{ needs.analyze-changes.outputs.new-version }}
          path: release-metrics.json
          retention-days: 365
      
      - name: Notify stakeholders
        run: |
          NEW_VERSION="${{ needs.analyze-changes.outputs.new-version }}"
          RELEASE_URL="${{ needs.create-release.outputs.release-url }}"
          RELEASE_TYPE="${{ needs.analyze-changes.outputs.release-type }}"
          
          echo "ðŸ“¢ Release v$NEW_VERSION completed!"
          echo "ðŸ”— $RELEASE_URL"
          
          # In production, send notifications
          # Slack notification
          # curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
          #   -H 'Content-type: application/json' \
          #   --data '{
          #     "text": "ðŸš€ New Pitchey release v'$NEW_VERSION' ('$RELEASE_TYPE') is now live!\n\nRelease Notes: '$RELEASE_URL'\nProduction: https://pitchey-5o8.pages.dev"
          #   }'
          
          # Email notification (if configured)
          # Send email to stakeholders about the release
          
          echo "âœ… Release process completed successfully!"